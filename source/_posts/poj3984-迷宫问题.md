---
title: poj3984-迷宫问题
date: 2018-04-21 01:06:34
categories:
- acm
- POJ
tags:
- bfs
---

# 1.[题目](http://poj.org/problem?id=3984)

{% asset_img a.jpg %}

{% asset_img b.jpg %}

# 2.解析

* dfs模拟
* 记录路径

# 3.代码

```c++
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cstring>
using namespace std;
#define fi first
#define se second
typedef pair<int, int> P;
int maze[5][5];
P pre[5][5];
int vis[5][5];
int dir[][2]={1,0,-1,0,0,1,0,-1};
vector<P> rc;

void bfs(P st)
{
    queue<P> que;
    que.push(st);
    pre[st.fi][st.se]= P(-1,-1);
    vis[st.fi][st.se]=1;
    while(!que.empty()) {
        P fro = que.front();
        if (fro.fi == 4 && fro.se == 4) break;
        que.pop();
        for (int i = 0; i < 4; ++ i) {
            int nx = fro.fi + dir[i][0];
            int ny = fro.se + dir[i][1];
            if (nx >= 0 && nx < 5 && ny >= 0 && ny < 5 && maze[nx][ny] == 0 && !vis[nx][ny]) {
                vis[nx][ny] = 1;
                que.push(P(nx, ny));
                pre[nx][ny] = fro;
            }
        }
    }
}

int main()
{
    for (int i = 0; i < 5; ++ i) {
        for (int j = 0; j < 5; ++ j) {
            scanf("%d", &maze[i][j]);
        }
    }
    memset(vis, 0, sizeof(vis));
    bfs(P(0, 0));
    P p = P(4, 4);
    while (p != P(-1, -1)) {
        rc.push_back(p);
        p = pre[p.fi][p.se];
    }
    reverse(rc.begin(), rc.end());
    for(int i = 0; i < rc.size(); ++ i){
        printf("(%d, %d)\n",rc[i].fi, rc[i].se);
    }
    return 0;
}
```

