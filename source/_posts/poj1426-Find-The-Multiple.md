---
title: poj1426-Find-The-Multiple
date: 2018-04-26 22:56:02
categories:
- acm
- POJ
tags:
- 暴力
---

# 1.[题目](http://poj.org/problem?id=1426)

{% asset_img a.jpg %}

{% asset_img b.jpg %}

# 2.解析

## 2.1 暴力打表

* java大数 + dfs打表， 因为只有200个结果

## 2.2 bfs + 同余模定理（正解）

* 给出一个整数n，(1 <= n <= 200)。求出任意一个它的倍数m，要求m必须只由十进制的'0'或'1'组成。
* [博客链接(待学习)]( https://blog.csdn.net/lyy289065406/article/details/6647917)

# 3. 代码

## 3.1 打表实现

### 3.1.1 java打表程序

```java

import java.math.*;

public class Main {
	
	public static BigInteger res;

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		for (int i = 1; i <= 200; ++ i) {
			res = BigInteger.ZERO;
			dfs(BigInteger.ONE, i);
			if (i == 200) System.out.println("\"" + res + "\"");
			else System.out.println("\"" + res + "\"" + ",");
		}
		
	}
	
	public static void dfs(BigInteger p, int n) {
		if (p.toString().length()>100) return;
		if (res.compareTo(BigInteger.ZERO)!=0 && p.compareTo(res)>=0) return;
		if (p.mod(BigInteger.valueOf(n)).equals(BigInteger.ZERO)) {
			if (res.equals(BigInteger.ZERO)) res = p;
			else if (res.compareTo(p)>0) res = p;
			return;
		}
		dfs(p.multiply(BigInteger.valueOf(10)).add(BigInteger.ONE), n);
		dfs(p.multiply(BigInteger.valueOf(10)), n);
	}

}
```

### 3.1.2 提交程序

```c++
#include <iostream>
using namespace std;

string s[]={"1",
"10",
"111",
"100",
"10",
"1110",
"1001",
"1000",
"111111111",
"10",
"11",
"11100",
"1001",
"10010",
"1110",
"10000",
"11101",
"1111111110",
"11001",
"100",
"10101",
"110",
"110101",
"111000",
"100",
"10010",
"1101111111",
"100100",
"1101101",
"1110",
"111011",
"100000",
"111111",
"111010",
"10010",
"11111111100",
"111",
"110010",
"10101",
"1000",
"11111",
"101010",
"1101101",
"1100",
"1111111110",
"1101010",
"10011",
"1110000",
"1100001",
"100",
"100011",
"100100",
"100011",
"11011111110",
"110",
"1001000",
"11001",
"11011010",
"11011111",
"11100",
"100101",
"1110110",
"1111011111",
"1000000",
"10010",
"1111110",
"1101011",
"1110100",
"10000101",
"10010",
"10011",
"111111111000",
"10001",
"1110",
"11100",
"1100100",
"1001",
"101010",
"10010011",
"10000",
"1111111101",
"111110",
"101011",
"1010100",
"111010",
"11011010",
"11010111",
"11000",
"11010101",
"1111111110",
"1001",
"11010100",
"10000011",
"100110",
"110010",
"11100000",
"11100001",
"11000010",
"111111111111111111",
"100",
"101",
"1000110",
"11100001",
"1001000",
"101010",
"1000110",
"100010011",
"110111111100",
"1001010111",
"110",
"111",
"10010000",
"1011011",
"110010",
"1101010",
"110110100",
"10101111111",
"110111110",
"100111011",
"111000",
"11011",
"1001010",
"10001100111",
"11101100",
"1000",
"11110111110",
"11010011",
"10000000",
"100100001",
"10010",
"101001",
"11111100",
"11101111",
"11010110",
"11011111110",
"11101000",
"10001",
"100001010",
"110110101",
"100100",
"10011",
"100110",
"1001",
"1111111110000",
"11011010",
"100010",
"1100001",
"11100",
"110111",
"11100",
"1110001",
"11001000",
"10111110111",
"10010",
"1110110",
"1010100",
"10101101011",
"100100110",
"100011",
"100000",
"11101111",
"11111111010",
"1010111",
"1111100",
"1111110",
"1010110",
"11111011",
"10101000",
"10111101",
"111010",
"1111011111",
"110110100",
"1011001101",
"110101110",
"100100",
"110000",
"100101111",
"110101010",
"11010111",
"11111111100",
"1001111",
"10010",
"100101",
"110101000",
"1110",
"100000110",
"1001011",
"1001100",
"1010111010111",
"110010",
"11101111",
"111000000",
"11001",
"111000010",
"101010",
"110000100",
"1101000101",
"1111111111111111110",
"111000011",
"1000"};

int main()
{
    int n;
    while (cin>>n && n) {
        cout << s[n-1] << endl;
    }
    return 0;
}

```

## 3.2 bfs+同余模定理 实现

```c++
#include<iostream>
using namespace std;

int mod[524286];  //保存每次mod n的余数
                  //由于198的余数序列是最长的
                  //经过反复二分验证，436905是能存储198余数序列的最少空间
                  //但POJ肯定又越界测试了...524286是AC的最低下限，不然铁定RE

int main(int i)
{
    int n;
    while(cin>>n)
    {
        if(!n)
            break;

        mod[1]=1%n;  //初始化，n倍数的最高位必是1

        for(i=2;mod[i-1]!=0;i++)  //利用同余模定理，从前一步的余数mod[i/2]得到下一步的余数mod[i]
            mod[i]=(mod[i/2]*10+i%2)%n;
                     //mod[i/2]*10+i%2模拟了BFS的双入口搜索
                     //当i为偶数时，+0，即取当前位数字为0  。为奇数时，则+1,即取当前位数字为1

        i--;
        int pm=0;
        while(i)
        {
            mod[pm++]=i%2;   //把*10操作转化为%2操作，逆向求倍数的每一位数字
            i/=2;
        }
        while(pm)
            cout<<mod[--pm];  //倒序输出
        cout<<endl;
    }
    return 0;
}

```