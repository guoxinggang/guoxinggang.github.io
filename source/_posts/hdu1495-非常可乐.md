---
title: hdu1495-非常可乐
date: 2018-04-21 13:43:50
categories:
- acm
- HDU
tags:
- bfs
- numbertheory
---

# 1.[题目](http://acm.hdu.edu.cn/showproblem.php?pid=1495)

{% asset_img a.jpg %}

{% asset_img b.jpg %}

# 2. 解析

## 2.1 bfs

* 已知 S,  N,  M
* 初始状态(s==S, n==0, m==0) --> 结束状态(s==S>>1, n==S>>1, m==0); (其中n >= m)
* 转移方式六种: s-->n, s-->m, n-->s, n-->m, m-->s, m-->n
* 求最短转移次数，所以使用BFS模拟
* n 和 m 能被转移的前提条件: n != N  m != M

## 2.2 数论（保留）

{% asset_img c.jpg %}

# 3. 代码

## 3.1 bfs实现

```c++
#include <bits/stdc++.h>
using namespace std;

typedef struct node{
    int s, n, m, step;
}Node;
int s, n, m;
int vis[101][101];  //s 已知, 二维状态表示三维

int bfs(Node st)
{
    queue<Node> que;
    que.push(st);
    vis[st.s][st.n] = 1;
    while (!que.empty()) {
        Node fro = que.front(); que.pop();
        if (fro.s == fro.n && fro.s == s/2) return fro.step;
        if (fro.s && fro.n != n) {
            // s --> n
            int c = min(fro.s, n-fro.n);
            if (!vis[fro.s-c][fro.n+c]) {
                que.push(Node{fro.s-c, fro.n+c, fro.m, fro.step+1});
                vis[fro.s-c][fro.n+c] = 1;
            }
        }
        if (fro.s && fro.m != m) {
            // s --> m
            int c = min(fro.s, m-fro.m);
            if (!vis[fro.s-c][fro.n]) {
                que.push(Node{fro.s-c, fro.n, fro.m+c, fro.step+1});
                vis[fro.s-c][fro.n] = 1;
            }
        }
        if (fro.n && !vis[fro.s+fro.n][0]) {
            // n --> s
            que.push(Node{fro.s+fro.n, 0, fro.m, fro.step+1});
            vis[fro.s+fro.n][0] = 1;
        }
        if (fro.m && !vis[fro.s+fro.m][fro.n]) {
            // m --> s
            que.push(Node{fro.s+fro.m, fro.n, 0, fro.step+1});
            vis[fro.s+fro.m][fro.n] = 1;
        }
        if (fro.n && fro.m != m) {
            // n --> m
            int c = min(fro.n, m-fro.m);
            if (!vis[fro.s][fro.n-c]) {
                que.push(Node{fro.s, fro.n-c, fro.m+c, fro.step+1});
                vis[fro.s][fro.n-c] = 1;
            }
        }
        if (fro.m && fro.n != n) {
            // m --> n
            int c = min(fro.m, n-fro.n);
            if (!vis[fro.s][fro.n+c]) {
                que.push(Node{fro.s, fro.n+c, fro.m-c, fro.step+1});
                vis[fro.s][fro.n+c] = 1;
            }
        }
    }
    return 0;
}

int main()
{
    while (scanf("%d %d %d", &s, &n, &m)!=EOF) {
        if (s + n + m == 0) break;
        if (n < m) swap(n, m);
        if (s % 2 == 1) printf("NO\n");
        else {
            memset(vis, 0, sizeof(vis));
            int r = bfs(Node{s, 0, 0, 0});
            if (r) printf("%d\n", r);
            else printf("NO\n");
        }
    }
    return 0;
}

```



## 3.2 数论推导实现（保留）

```C++
#include <bits/stdc++.h>
using namespace std;

int s, n, m;

int gcd(int a, int b) 
{
    return b == 0 ? a : gcd(b, a%b);
}

int main()
{
    while (scanf("%d %d %d", &s, &n, &m)!=EOF) {
        if (s + n + m == 0) break;
        s /= gcd(n, m);
        if (s&1) printf("NO\n");
        else printf("%d\n", s-1);
    }
    return 0;
}
```

